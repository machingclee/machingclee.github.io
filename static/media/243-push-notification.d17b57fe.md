---
title: "Push-Notification in Android and iOS via Expo"
date: 2024-02-20
id: blog0243
tag: react-native, nodejs, expo
intro: "We record how to implement push-notification in both Android and iOS."
toc: true
---

<style>
  img {
    max-width: 660px;
  }
</style>


#### To Receive Push Notification

##### Android (Configure Firebase Project)


- [Firebase Console](https://console.firebase.google.com/u/0/)


- For now since we don't have a google account for all mobile application, the following credentials are generated by using `james.lee@wonderbricks.com`. 

- The generation steps are simple to replicate:


- We can create ***one*** project for ***four*** environments.
  - ***Repeatedly*** Click Plus Sign

    ![](/assets/img/2024-02-28-07-37-19.png)

  - ***Repeatedly*** Click

    ![](/assets/img/2024-02-28-07-37-29.png)

  - ***Repeatedly*** Fill in the package name

    ![](/assets/img/2024-02-28-07-37-39.png)


- We create 4 `package` name with only ***characters and underscores*** (android don't allow `-` in package name):

  - `com.XXX.XXXX_dev`
  - `com.XXX.XXXX_uat`
  - `com.XXX.XXXX_poc`
  - `com.XXX.XXXX_prod`

- Project Setting

  ![](/assets/img/2024-02-28-07-37-48.png)

- Manage API in Google Cloud Console:

  ![](/assets/img/2024-02-28-07-37-54.png)

- Enable

  ![](/assets/img/2024-02-28-07-38-01.png)

- After we enabled successfully:

  ![](/assets/img/2024-02-28-07-38-09.png)

  ```text
  AAAA95L1NUI:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ```


- [Expo Account Dashboard](https://expo.dev/accounts/machingclee)

- Click Credentials:

  ![](/assets/img/2024-02-28-07-38-17.png)

- Add a FCM (Legacy) server key:

  ![](/assets/img/2024-02-28-07-38-30.png)




##### iOS
- There is `expo` cli command to automatically config everything for us

- When everything suddenly fails, we need to know how to fix it, so we study how to do it manually.

- First go to [apple devleoper console](https://developer.apple.com/).

- Scroll to the bottom and click *Certificates, IDs, & Profiles*:

  [![](/assets/img/2025-10-03-03-19-14.png)](/assets/img/2025-10-03-03-19-14.png)


- Choose *Keys* and Click the *Plus* sign:

  [![](/assets/img/2025-10-03-03-21-08.png)](/assets/img/2025-10-03-03-21-08.png)


- Choose APNs, fill the key name and continue

  [![](/assets/img/2025-10-03-03-22-55.png)](/assets/img/2025-10-03-03-22-55.png)

- Choose to use *Sandbox & Production* so that the same key can be used in both testflight and production environment

  [![](/assets/img/2025-10-03-03-24-01.png)](/assets/img/2025-10-03-03-24-01.png)

- In expo console choose the target identifier, upload the `.p8` key file and fill in the information from apple developer console:

  [![](/assets/img/2025-10-03-03-27-22.png)](/assets/img/2025-10-03-03-27-22.png)

  **Important.** `KeyID` must be the same.

#### Page to Create Access Token

By default everyone who owns the device's `expo-push-notification-token`  can send push-notification to that device. Expo provides one additional layer to prevent malacious use of a notification token (just in case someone gets the token for some reason)


- [Get Access Token Here](https://expo.dev/accounts/machingclee/settings/access-tokens)

You can use this token in <a href="#pushNotificationUtil.ts" target="_self">pushNotificationUtil.ts</a> section.


##### Personal Access Tokens
```text
vWXyXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

##### Create Robot Users

```text
i-QtXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

##### Toggle the Enhanced Security for Push Notifications (Optional)

![](/assets/img/2024-02-28-07-39-10.png)

<center></center>

After that any naked `POST` request cannot send notification to your user even they own the `push-notification-token` of that user.

![](/assets/img/2024-02-28-07-39-15.png)





#### Receive Notification in Mobile
 
##### Frontend
###### Create a PushNotification Token at Entrypoint

We use the following hook 

```js
// hooks/usePushNotification.ts

import { useState, useEffect, useRef } from 'react';
import { Text, View, Button, Platform } from 'react-native';
import * as Device from 'expo-device';
import * as Notifications from 'expo-notifications';
import Constants from 'expo-constants';
import msgUtil from '../util/msgUtil';
import { useAppDispatch, useAppSelector } from '../redux/app/hooks';
import appSlice, { appThunkAction } from '../redux/slices/appSlice';
import { PushNotificationData } from '../dto/dto';
import { useRouter } from 'expo-router';
import projectAndChannelSlice from '../redux/slices/projectAndChannelSlice';

const configNotificationHandler = () => {
    Notifications.setNotificationHandler({
        handleNotification: async () => ({
            shouldShowAlert: true,
            shouldPlaySound: true,
            shouldSetBadge: false,
        }),
    });
}

async function getNotificationTokenAsync(userId: string) {
    if (Platform.OS === 'android') {
        Notifications.setNotificationChannelAsync('default', {
            name: 'default',
            importance: Notifications.AndroidImportance.MAX,
            vibrationPattern: [0, 250, 250, 250],
            lightColor: '#FF231F7C',
        });
    }

    if (Device.isDevice) {
        const { status: existingStatus } = await Notifications.getPermissionsAsync();
        let finalStatus = existingStatus;
        console.log("finalStatusfinalStatusfinalStatus", finalStatus);
        if (existingStatus !== 'granted') {
            const { status } = await Notifications.requestPermissionsAsync();
            finalStatus = status;
        }
        if (finalStatus !== 'granted') {
            alert('Failed to get push token for push notification!');
            return;
        }
        const token = await Notifications.getExpoPushTokenAsync({
            projectId: Constants?.expoConfig?.extra?.eas.projectId || "",
        });

        return token.data;
    } else {
        throw new Error("Must use physical device for Push Notifications");
    }
}

export default function usePushNotification() {
    const dispatch = useAppDispatch();
    const router = useRouter();
    configNotificationHandler();
    const notificationListener = useRef<Notifications.Subscription>();
    const responseListener = useRef<Notifications.Subscription>();

    const subscribeNotification = async (userId: string) => {
        try {
            const token = await getNotificationTokenAsync(userId);
            console.log("tokentokentokentoken", token);
            if (token) {
                await dispatch(appThunkAction.providePushNotificationToken({ pushNotificationToken: token })).unwrap();
            }
        } catch (err) {
            msgUtil.persistedError(JSON.stringify(err));
        }

        notificationListener.current = Notifications.addNotificationResponseReceivedListener(response => {
            const { actionIdentifier, notification } = response;
            const { date, request } = response;
            // actionA
        });

        responseListener.current = Notifications.addNotificationResponseReceivedListener(response => {
            const { notification } = response;
            const data = notification.request.content.data as PushNotificationData;
            // action B
        });

        return () => {
            if (notificationListener?.current) {
                Notifications.removeNotificationSubscription(notificationListener?.current);
            }
            if (responseListener?.current) {
                Notifications.removeNotificationSubscription(responseListener?.current);
            }
        };

    }

    return { subscribeNotification }
}
```




We will call `subscribeNotification()` whenever we try to login. 

For example, in the entrypoint of our application:

```js
export default () => {
    const [_, setHydrated] = useState(false); // force rerendering only
    const { accessToken, userId } = useAppSelector(s => s.auth);
    const dispatch = useAppDispatch();
    const { subscribeNotification } = usePushNotification();
   
    ...

    useEffect(() => {
        if (!accessToken) {
            router.push("/login")
        } else {
            subscribeNotification(userId);
        }
    }, [accessToken]);

    useEffect(() => {
        setTimeout(() => {
            setHydrated(true);
        }, 1);
    }, [])

    return (
        ...
    )
}
```
This effect will be executed everytime we login or launch the application.


Note that `action A` and `action B` inside `subscribeNotification` have different behaviour:

###### Control the User's Behaviour (User being Passive)

- Look at the hook ahove, `actionA` will be executed only when user is in-app, moreover, the action will take place without user's consent.

###### User Controles the Behaviour (User being Active)

- Look at the hook above, `actionB` will be executed when user ***tap into*** the application.



##### Backend (Receive Push Notification Token via Upsert)

```js
// controller: 

const providePushNotificationToken = async (req: Request, res: Response) => {
    const userEmail = req.user?.email || "";
    const { pushNotificationToken } = req.body as { pushNotificationToken: string };

    await db.insertInto("PushNotification")
        .values({ userEmail, token: pushNotificationToken })
        .onConflict(oc => oc
            // `userEmail` is the only unique-key constraint
            .columns(["userEmail"])
            .doUpdateSet(eb => ({ token: eb.ref("excluded.token") }))
        )
        .execute();
    res.json({ success: true });
}
```


[![](/assets/img/2024-02-28-07-57-43.png)](/assets/img/2024-02-28-07-57-43.png)

#### Send Notification via Backend
##### Nodejs Library to Send Notification 
- Resource: [send-push-notifications-using-a-server](https://docs.expo.dev/push-notifications/sending-notifications/#send-push-notifications-using-a-server)

- We use this [npm package](https://www.npmjs.com/package/expo-server-sdk).

- Note that the npm package also do the ***Limit Concurrent Connections*** for us.
 
##### pushNotificationUtil.ts

```js
import { Expo, ExpoPushMessage, ExpoPushTicket } from 'expo-server-sdk';

type PushNotificationData = {
    projectId: string,
    channelId: string,
}

const expo = new Expo({ accessToken: process.env.EXPO_ACCESS_TOKEN });

const forwardMessages = async (params: {
    tokens: string[],
    message: {
        title: string,
        body: string,
        data: PushNotificationData
    }
}) => {
    const { message, tokens } = params;
    const { body, data, title } = message;
    const messages: ExpoPushMessage[] = []
    for (const token of tokens) {
        messages.push({
            to: token,
            sound: 'default',
            body: body,
            data,
            title
        })
    }
    const chunks = expo.chunkPushNotifications(messages);
    const tickets: ExpoPushTicket[] = []
    for (const chunk of chunks) {
        try {
            const ticketChunk = await expo.sendPushNotificationsAsync(chunk);
            console.log(ticketChunk);
            tickets.push(...ticketChunk);
            // NOTE: If a ticket contains an error code in ticket.details.error, you
            // must handle it appropriately. The error codes are listed in the Expo
            // documentation:
            // https://docs.expo.io/push-notifications/sending-notifications/#individual-errors
        } catch (error) {
            console.error(error);
        }
    }

    const successReceiptIds = [];
    for (let ticket of tickets) {
        // NOTE: Not all tickets have IDs; for example, tickets for notifications
        // that could not be enqueued will have error information and no receipt ID.
        if (ticket.status === "ok" && ticket?.id) {
            successReceiptIds.push(ticket.id);
        }
    }

    let receiptIdChunks = expo.chunkPushNotificationReceiptIds(successReceiptIds);
    (async () => {
        // Like sending notifications, there are different strategies you could use
        // to retrieve batches of receipts from the Expo service.
        for (let chunk of receiptIdChunks) {
            try {
                let receipts = await expo.getPushNotificationReceiptsAsync(chunk);
                console.log(receipts);

                // The receipts specify whether Apple or Google successfully received the
                // notification and information about an error, if one occurred.
                for (let receiptId in receipts) {
                    const receipt = receipts[receiptId];
                    let { status, details } = receipt

                    if (status === 'ok') {
                        continue;
                    } else if (status === 'error') {
                        console.error(
                            `There was an error sending a notification: ${JSON.stringify(details)}`
                        );
                    }
                }
            } catch (error) {
                console.error(error);
            }
        }
    })();
}

export default {
    forwardMessages
}
```


##### notificationService.ts


Here the backend logic differs from the businesss, for us we push notification for different channels, and each user has their own token in the `PushNotification` Table:

```js
import { channel } from "diagnostics_channel";
import { db } from "../db/kysely/database";
import pushNotificationUtil from "../util/pushNotificationUtil";

const notifyChannel = async (params: {
    excludeUserEmails: string[],
    channelId: string,
    title?: string,
    body?: string
}) => {
    const { excludeUserEmails, channelId, title, body } = params;
    const targetChannel = await db.selectFrom("Channel")
        .select(["Channel.name", "Channel.projectId"])
        .where("Channel.id", "=", channelId)
        .executeTakeFirst();
    if (!targetChannel) {
        throw new Error("Channel does not exist");
    }
    const allTokenExceptMeInsideChannel = await db.selectFrom("UserToChannel")
        .leftJoin("User", "User.companyEmail", "UserToChannel.userEmail")
        .leftJoin("PushNotification", "PushNotification.userEmail", "User.companyEmail")
        .select("PushNotification.token")
        .where("PushNotification.userEmail", "not in", excludeUserEmails)
        .where("UserToChannel.channelId", "=", channelId)
        .execute();
    const tokens = allTokenExceptMeInsideChannel.filter(t => t.token).map(t => t.token!);
    pushNotificationUtil.forwardMessages({
        tokens,
        message: {
            title: title || "Issue Update",
            data: {
                channelId,
                projectId: targetChannel.projectId || "",
            },
            body: body || `New Issue in Channel ${targetChannel.name}`,
        }
    })
}

export default {
    notifyChannel
}
```

Of course you can build more reusable notification strategy in this file!