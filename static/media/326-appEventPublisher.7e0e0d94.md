---
title: "Application Event Publisher for Monolithic DDD in Nodejs"
date: 2024-09-30
id: blog0326
tag: nodejs, express, DDD
toc: true
intro: "We have talked about monolithic DDD in the context of spring boot with the help of spring-provided ApplicationEventPublisher instance via dependency injection. This is not unique to spring and let's bring it into nodejs in the express framework."
---

<style>
  img {
    max-width: 660px;
  }
</style>

#### Preface 
In the past we have discussed monolithic DDD in an article 
- [Monolithic DDD Without ORM by Separating Data and Domain Behaviour](/blog/article/Monolithic-DDD-Without-ORM-by-Separating-Data-and-Domain-Behaviour)
where we rely heavily on the `ApplicationEventPublisher` instance injected by spring boot framework. 

Now in this article we will be creating an `ApplicationEventPublisher` that works almost the same by using [eventemitter3](https://www.npmjs.com/package/eventemitter3).


#### Publisher Result

In the following `id` is generated when inserting the data:

![](/assets/img/2024-09-30-04-21-06.png)

As is to be seen when we define `AppliactionEvent` in the next section, `event.result` is `null` before dispatching the event. Therefore the presence of `event.result` indicates the `ApplicationEventPublisher` instance functions as expected. 


#### ApplicationEvent and Application Event Publisher

```ts{3}
import EventEmitter from 'eventemitter3';

export class ApplicationEvent<S extends string, T, R = T> {
    public result: R | null = null
    constructor(
        public type: S,
        public data: T,
    ) { }
}
```
- Here `result` is used to retrieve the eventual result from the event handler in which the `event` object gets mutated.

- For example when we have created a `Student` object, we may wish to get the instance back and return at least the `id` (generated by database) to the frontend.

```ts-9{14}
type InferEventType<T> = T extends ApplicationEvent<infer U, any> ? U : never;

type EventProcessor<Event = any> = (event: Event) => void | Promise<void>;
type OrderedEventHandler<Event = any> = { processor: EventProcessor<Event>, order: number }

class ApplicationEventPublisher {
    private eventEmitter: EventEmitter;
    private handlers: Map<string, OrderedEventHandler[]> = new Map<string, OrderedEventHandler[]>()

    constructor() {
        this.eventEmitter = new EventEmitter();
    }

    async publishEvent<S extends string, T>(event: ApplicationEvent<S, T>): Promise<void> {
        const handlers = this.handlers.get(event.type).sort((a, b) => a.order - b.order);
        if (handlers) {
            for (const handler of handlers) {
                const processor = handler.processor as EventProcessor<typeof event>
                await processor(event)
            }
        }
    }

    addEventHandler = <T>(evenType: InferEventType<T>, handler: EventProcessor<T>, order: number = 1): void => {
        if (!this.handlers.has(evenType)) {
            this.handlers.set(evenType, []);
        }
        this.handlers.get(evenType)!.push({ processor: handler, order });
    }
}

export const applicationEventPublisher = new ApplicationEventPublisher();
export default ApplicationEventPublisher;
```

Note that when no constructor is defined, the parent constructor will be called automatically.


##### EventHandlers

###### studentEventHandler.ts

```ts
import { db } from "../../db/database";
import { StudentCreatedEvent } from "../repository/StudentRepository";
import { applicationEventPublisher } from "../../src/util/ApplicationEventPublisher";
import { PackageDeletedEvent, PackageUpdatedEvent, StudentInfoUpdatedEvent } from "../aggregate/StudentDomain";

export const registerStudentEvents = () => {
    const on = applicationEventPublisher.addEventHandler

    on<StudentCreatedEvent>("StudentCreatedEvent", async (event) => {
        const student = event.data
        const student_ = await db.insertInto("Student").values(student).returningAll().executeTakeFirst()
        if (!student_) {
            throw new Error("Studnet insertion fails")
        }
        event.result = student_
    })

    on<StudentInfoUpdatedEvent>("StudentInfoUpdatedEvent", async (event) => {
        const { update } = event.data
        await db.updateTable("Student").set(update).where("Student.id", "=", update.id).execute();
    })

    on<PackageDeletedEvent>("PackageDeletedEvent", async (event) => {
        const { packageId } = event.data;
        await db.deleteFrom("Student_package").where("Student_package.id", "=", Number(packageId)).execute();
    })
}
```

#### Experiment

##### Before we Design Aggregates from Table of Relations

Let's consider the following relations:

<a href="/assets/img/2024-09-30-03-42-57.png" target="_blank">![](/assets/img/2024-09-30-03-42-57.png)</a>

- A **_student_** has many **_packages_**, each **_package_** has many **_classes_**.

- Each of the three entities has very rich domain behaviours.

- Hierarchically packages and classes should be inside of the `StudentDomain` aggregate by what we learn about what consitutes an aggregate. But recall from

  > [What makes an Aggregate (DDD)? Hint: it's NOT hierarchy & relationships](https://www.youtube.com/watch?v=djq0293b2bA)

  by CodeOpinion

  - We should think about what's the actual behaviours?

  - What consistency do we need within a cluster of entities?

  - Query Performance? Do we always need all informations?

  By these considerations it makes sense to break an aggregate into smaller aggregates, when a vending machine dispatch an alarm, we let `Route` aggregate to listen on the domain event, consume it, and execute subsequent action:

  ![](/assets/img/2024-09-30-03-55-09.png)

##### Define Aggregates

###### AbstractAggregateRoot

Let's define a base class for our aggregates. We intentionally not to use abstract class because special config in `package.json` needs to be set to make it work.

```ts
import { ApplicationEvent, applicationEventPublisher } from "../../src/util/ApplicationEventPublisher"

export default class AbstractAggregateRoot {

    private events: any[] = []

    public save = async () => {
        for (const event of this.events) {
            await applicationEventPublisher.publishEvent(event)
        }
        this.events = []
    }

    public registerEvent = <S extends string, T>(event: ApplicationEvent<S, T>) => {
        this.events.push(event)
    }
}
```

###### StudentDomain

```ts
import { Student, Student_package } from "@prisma/client"
import AbstractAggregateRoot from "./AbstractAggregateRoot"
import ApplicationEventPublisher, { ApplicationEvent } from "../../src/util/ApplicationEventPublisher";
import { UpdatePackageRequest, UpdateStudentRequest } from "../../dto/dto";
import updateValues from "../../src/util/updateValues";

export class StudentInfoUpdatedEvent extends ApplicationEvent<"StudentInfoUpdatedEvent", { update: UpdateStudentRequest }> { }
export class PackageUpdatedEvent extends ApplicationEvent<"PackageUpdatedEvent", { update: UpdatePackageRequest }> { }
export class PackageDeletedEvent extends ApplicationEvent<"PackageDeletedEvent", { packageId: number }> { }

export default class StudentDomain extends AbstractAggregateRoot {
    constructor(
        private student: Student | null,
        private packages: Student_package[],
    ) {
        super()
    }

    updateInfo = (update: UpdateStudentRequest) => {
        this.student = { ...this.student, ...update }
        this.registerEvent(new StudentInfoUpdatedEvent("StudentInfoUpdatedEvent", { update }))
    }

    updatePackage = (update: UpdatePackageRequest) => {
        const package_ = this.packages.find(p => p.id === update.id)
        updateValues(package_, update)
        this.registerEvent(new PackageUpdatedEvent("PackageUpdatedEvent", { update }))
    }

    deletePackage = (packageId: number) => {
        const index = this.packages.findIndex(p => p.id === packageId)
        this.packages.splice(index, 1)
        this.registerEvent(new PackageDeletedEvent("PackageDeletedEvent", { packageId }))
    }
}
```

Recall that domain behaviours need to be published for other domain object to subscribe. By using `save()` method we will dispatch all the events we registered (refer to the `AbstractAggregateRoot` definition).

##### Define StudentCreatedEvent and StudentRepository

Recall that a **_repository_** by convention is defined to return **_aggregate root(s)_**. In our convention each aggregate will be called `something-Domain`.

```ts
import { Student, Student_package } from "@prisma/client"
import StudentDomain from "../aggregate/StudentDomain"
import { db } from "../../db/database"
import { jsonArrayFrom, jsonObjectFrom } from "kysely/helpers/postgres";
import { applicationEventPublisher, ApplicationEvent } from "../../src/util/ApplicationEventPublisher"
import { CreateStudentRequest } from "../../dto/dto"

export class StudentCreatedEvent extends ApplicationEvent<"StudentCreatedEvent", CreateStudentRequest> { }


class StudentRepository {
    createRoot = async (student: CreateStudentRequest): Promise<StudentDomain> => {
        const event = new StudentCreatedEvent("StudentCreatedEvent", student)
        const result = await applicationEventPublisher.publishEvent(event)
        return new StudentDomain(event.result as Student, [], applicationEventPublisher)
    }

    getStudentById = async (uuid: string): Promise<StudentDomain> => {
        const result = await studentAggQuery
            .where("Student.id", "=", uuid)
            .executeTakeFirst()
        if (!result) {
            return new StudentDomain(null, [], applicationEventPublisher)
        }
        const { studentPackages, ...student } = result
        const studentDomain = new StudentDomain(student, studentPackages, applicationEventPublisher)
        return studentDomain
    }

    getStudentsByParentEmail = async (email: string): Promise<StudentDomain[]> => {
        const result = await studentAggQuery
            .where("Student.parent_email", "=", email)
            .execute()
        if (!result) {
            return []
        }
        const studentDomains: StudentDomain[] = [];
        result.forEach(r => {
            const { studentPackages, ...student_ } = r
            const studentDomain = new StudentDomain(student_, studentPackages, applicationEventPublisher)
            studentDomains.push(studentDomain)
        })
        return studentDomains
    }
}

const studentAggQuery = db.selectFrom("Student")
    .selectAll("Student")
    .select((eb) => [
        jsonArrayFrom(
            eb
                .selectFrom("Student_package")
                .selectAll("Student_package")
                .whereRef("Student_package.student_id", "=", "Student.id")
        ).as("studentPackages"),
    ])

export const studentRepository = new StudentRepository();
export default StudentRepository;
```

##### Let's Dispatch a StudentCreatedEvent!

Let's study the simplest case of domain event: create a `Student` aggregate. Recall that we have defined a listener to create a `Student` in `studentEventHandler.ts`.

```ts
const createStudent = async (req: Request, res: Response) => {
  const body = req.body as CreateStudentRequest;
  const studentDomain = await studentRepository.createRoot(body);
  res.json({
    success: true,
  });
};
```

We have demonstrated the result at the beginning of this article, let's review it:

![](/assets/img/2024-09-30-04-21-06.png)



##### Let's Execute StudentDomain.{updateInfo, updatePackage, deletePackage}

Finally let's go through basic CRUD examples using this methodology:

```ts
const updateStudent = async (req: Request, res: Response) => {
    const body = req.body as UpdateStudentRequest;
    const studentDomain = await studentRepository.getStudentById(body.id)
    studentDomain.updateInfo(body)
    await studentDomain.save()

    res.json({
        success: true,
        result: { student: body },
    });
};

const deletePackage = async (req: Request, res: Response) => {
    const params = req.query as { studentId: string, packageId: string };
    const { packageId, studentId } = params;
    const studentDomain = await studentRepository.getStudentById(studentId)
    studentDomain.deletePackage(Number(packageId))
    await studentDomain.save()
    res.json({
        success: true,
    });
};

const updatePackage = async (req: Request, res: Response) => {
    const packageUpdate = req.body as UpdatePackageRequest;
    const { student_id } = packageUpdate;
    const studentDomain = await studentRepository.getStudentById(student_id)
    studentDomain.updatePackage(req.body)
    await studentDomain.save();

    res.json({
        success: true,
        result: packageUpdate,
    });
};
```

Now to add new features, let's say we add an email notification after `deletePackage` is finished, then it is as simply as adding 

```ts
on<PackageDeletedEvent>("PackageDeletedEvent", async (event) => {
    // some logic to notify student by email
})
```

#### Order of EventHandlers

Back to our `deletePackage` example, it is implemented by:
```ts
await db.deleteFrom("Student_package").where("Student_package.id", "=", Number(packageId)).execute();
```
However, `Student_package` is referenced by `Class`'s via a foreign key, the request for now will result in the following error:

![](/assets/img/2024-10-01-23-40-45.png)

Since we didn't set foreign key as castcade delete, our `Class` entities will not be deleted automatically, therefore we have to sequentially:

1. Delete the classes referencing to this package

2. Delete this package

This can be handled by two eventHandlers (we can condense them into one of course, but let's demonstrate how to order events).

```ts{5,10}
// studentEventHandler.ts
    on<PackageDeletedEvent>("PackageDeletedEvent", async (event) => {
        const { packageId } = event.data;
        await db.deleteFrom("Student_package").where("Student_package.id", "=", packageId).execute();
    }, 2)

    on<PackageDeletedEvent>("PackageDeletedEvent", async (event) => {
        const { packageId } = event.data;
        await db.deleteFrom("Class").where("Class.student_package_id", "=", packageId).execute();
    }, 1)
```

#### References

- [What makes an Aggregate (DDD)? Hint: it's NOT hierarchy & relationships](https://www.youtube.com/watch?v=djq0293b2bA), CodeOpinion

- [Monolithic DDD Without ORM by Separating Data and Domain Behaviour](/blog/article/Monolithic-DDD-Without-ORM-by-Separating-Data-and-Domain-Behaviour), Ching-C Lee

The presence of `event.result` indicates the `applicationEventPublisher` functions as expected. Recall that by default we set `event.result = null` before dispatching the event.

