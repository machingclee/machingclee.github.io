---
title: "Server Sent Event in Java Backend"
date: 2023-07-21
id: blog0157
tag: java, spring
intro: "An introduce how to effectively create SSE event mimicing the single-thread event loop adopted by nodejs."
toc: true
---

#### Video Demonstration

<Center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gMSWdAZhupY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</Center>
<p></p>
This demonstrated:

- We can send event back to client;
- We can determine whether a client is disconnected.

#### Frontend Implementation

We create a `GET` request with header `Content-Type: text/event-stream` as follows:

```ts
import { useState } from "react";
import lodash from "lodash";
import axios from "axios";
export default function SSE() {
  const [msgs, setMsgs] = useState<string[]>([]);

  return (
    <>
      <button
        onClick={() => {
          const evtSource = new EventSource(
            "http://localhost:8080/gmail/event"
          );
          evtSource.addEventListener("message", (event) => {
            console.log("eventevent", event);
            setMsgs((datas) => {
              const datas_ = lodash.cloneDeep(datas);
              const newData = JSON.stringify(event.data);
              datas_.push(newData);
              return datas_;
            });
          });
        }}
      >
        Listen to a stream
      </button>

      <div>
        {msgs.map((msg) => {
          if (msg) {
            return <div>{msg}</div>;
          } else {
            return null;
          }
        })}
      </div>
    </>
  );
}
```

#### Backend Implementation

```java
@RestController
public class GmailController {
    ...
    @GetMapping(value = "/gmail/event", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @ResponseBody
    public Flux<ServerSentEvent<String>> getEvents() throws InterruptedException {

        return Flux.interval(Duration.ofSeconds(1))
                .map(seq -> {
                    System.out.println("Event Emitted!");
                    var sse = ServerSentEvent.<String>builder()
                            .event("message")
                            // .data(redisTemplate.opsForList().rightPop("mail-queue"))
                            .data("Some Message - " + seq.toString())
                            .build();
                    return sse;
                });
    }
}
```

- `Flux.interval` helps put our `callback` into a special queue at which a event loop will constantly look. This is analagous to `setInterval` in chrome and nodejs, which place the `callbacks` into a special queue and let the event loop to pick up. This is to prevent using single-threaded model to hold and send message to the client.

- Our connection with client will be kept once connected (using other queue), and the thread that takes the request to our controller will be released.

- We should not try to use a `while` loop (as in some tutorial) to hold the connection as it will certainly use up the number of threads in our thread pool easily.

- We should return `Flux<ServerSentEvent<String>>` instead of `Flux<String>` since `ServerSentEvent` objects also serve as a heartbit to tell whether a connection is disconnected or not.
