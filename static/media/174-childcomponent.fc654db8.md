---
title: "Custom Rendering of Custom Child Component"
date: 2023-09-07
id: blog0174
tag: react
intro: "We dicuss how to customize the way of rendering custom children component to produce highly reusable code."
toc: true
---

<style>
  img {
    max-width: 100%
  }
</style>

#### Component Study

Let's study the following forms:

<Center>
<a href="/assets/tech/174/003.png">
<img src="/assets/tech/174/003.png" />
</a>
</Center>

<p></p>

<center></center>

- We can obseve that there are many repititions.
- Working any single part is very easy, we just nest the CSS and the `<div>`'s.
- The problem becomes complicated when it comes to reusing what we have done.

#### Grabbing Child Compoenent of Desired Component Name

Before proceeding, let's discuss how a react component can identify certain special children component, extract them, and place it in our desired order:

```js
import React, { ReactNode } from "react";

function grabChildrenByType(children: ReactNode, type: string) {
	const mappedChildren = React.Children.map(children, (child) => {
		const child_ = child as (React.ReactElement<any> & { type?: { name?: string } });
		if (React.isValidElement(child_)
			&& (child_?.type?.name || "") === type
		) {
			return child;
		} else {
			return null;
		}
	}) as JSX.Element[];
	return mappedChildren;
}

export default { grabChildrenByType }
```

Basically each children should have `.type.name`.

Note that if a component is generated by a function with trait `() => () => JSX.Element`, then this compoonent will have empty string as its `.type.name`.

#### Divide the Component into Reusable ones

In general there are only two sub-components:

- ![](/assets/tech/174/004.png)

Let's denote `DC` as `DialogComponent`. The above component can be described by

```js
<DC.RadioRow>
	<DC.RadioRowButton>
		<RadioButton/>
	</DC.RadioRowButton>

	<DC.RadioRowTitle>
		Create New Buyer Company
	</DC.RadioRowTitle>
</DC.RadioRow>
```

where each of the dirty parts is defined below.

```js
export class DC {
	public static RadioRowButton({ children, ...props }: {
		children: ReactNode
	} & HTMLAttributes<HTMLDivElement>) { return <div {...props}>{children}</div> }
	public static RadioRowTitle({ children, ...props }: {
		children: ReactNode
	} & HTMLAttributes<HTMLDivElement>) { return <div {...props}>{children}</div> }

	public static RadioRow({ children, ...props }: { children: ReactNode } & HTMLAttributes<HTMLDivElement>) {
		const radioBlock = childUtil.grabChildrenByType(children, DC.RadioRowButton.name);
		const titleBlock = childUtil.grabChildrenByType(children, DC.RadioRowTitle.name);
		return (
			<div style={{ display: "flex" }}>
				<div style={{ display: "flex", justifyContent: "flex-end", }}>
					{radioBlock}
				</div>
				<div style={{ flex: 1 }}>
					<div style={{ paddingTop: 4 }}>{titleBlock}</div>
				</div>
			</div>
		)
	}
}
```
Note that `RadioRowButton` and `RadioRowTitle` are simply `children => children` and identitcal. They serve as a building block of our custom rendering.

- ![](/assets/tech/174/005.png)

This can be expressed by 
```js
<DC.InputRow>
	<DC.InputRowLeft>
		Choose Company
	</DC.InputRowLeft>
	<DC.InputRowRight>
		<GeneralDropdown fullList={buyerCompany} initialValue={null} />
	</DC.InputRowRight>
</DC.InputRow>
```
We hide all the dirty work by defining:
```js	
export class DC {
	public static InputRowLeft({ children, ...props }: { children: ReactNode } & HTMLAttributes<HTMLDivElement>) { return <div {...props}>{children}</div> }
	public static InputRowRight({ children, ...props }: { children: ReactNode } & HTMLAttributes<HTMLDivElement>) { return <div {...props}>{children}</div> }
	public static InputRow({ children, ...props }: { children: ReactNode } & HTMLAttributes<HTMLDivElement>) {
		const left = childUtil.grabChildrenByType(children, DC.InputRowLeft.name);
		const right = childUtil.grabChildrenByType(children, DC.InputRowRight.name);
		return (
			<tr>
				<td style={{ verticalAlign: "middle" }}>{left}</td>
				<td style={{ verticalAlign: "middle" }}>{right}</td>
			</tr>
		)
	}
```
Finally we want our component to be able to capture `<InputRow />` and `<RadioRow />` and inject the components in desired position.
```js
public static Body({ children, ...props }: { children: ReactNode } & HTMLAttributes<HTMLDivElement>) {
	const inputs = childUtil.grabChildrenByType(children, DC.InputRow.name);
	const radioRows = childUtil.grabChildrenByType(children, DC.RadioRow.name);
	return (
		<div {...props}>
			{radioRows}
			<Spacer height={5} />
			<Table sx={{
				"& td": {
					paddingTop: "5px"
				},
				"& td:nth-child(1)": {
					width: 160,
					verticalAlign: "middle",
					paddingLeft: "34px"
				},
				"& td:nth-child(2)": {
					verticalAlign: "middle"
				}
			}}>
				{inputs}
			</Table>
		</div>
	)
}
```
#### Final Result
- If we put all the single pieces into the component we want, it still looks very long. 
- But at least we don't need to mess around with the hard-coded CSS values, in this sense the code is more reusable.
- In case we want to change CSS, it is much more consistent.
```js
export type Step1FormData = {
	option?: string,
	company?: string,
	emailDomain?: string
}

export default ({ step1FormData }: { step1FormData: React.MutableRefObject<Step1FormData> }) => {
	const dispatch = useAppDispatch();
	const { RadioButton, selectedValue, setSelectedValue } = useWbRadioButtonGroup<string>();
	const updateField = (value: Partial<Step1FormData>) => {
		step1FormData.current = { ...step1FormData.current, ...value };
	}
	const [buyerCompany, setBuyerCompany] = useState<BuyerCompany[]>([]);

	useEffect(() => {
		dispatch(mailThunkAction.getBuyerCompanies())
			.unwrap()
			.then(data => { setBuyerCompany(data); })
			.catch(err => { snackbarUtils.error(JSON.stringify(err)) });
	}, []);


	return (
		<>
			<DC.Body>
				<DC.RadioRow>
					<DC.RadioRowButton>
						<RadioButton
							value={options.step1.CREATE_NEW_COMPANY}
							style={{ padding: 0, paddingRight: 10 }}
							onClick={() => { updateField({ option: options.step1.CREATE_NEW_COMPANY }) }}
						/>
					</DC.RadioRowButton>
					<DC.RadioRowTitle>
						Create New Buyer Company
					</DC.RadioRowTitle>
				</DC.RadioRow>

				<DC.InputRow>
					<DC.InputRowLeft>
						Choose Company
					</DC.InputRowLeft>
					<DC.InputRowRight>
						<GeneralDropdown fullList={buyerCompany} initialValue={null} />
					</DC.InputRowRight>
				</DC.InputRow>

				<DC.InputRow>
					<DC.InputRowLeft>
						Email Domain
					</DC.InputRowLeft>
					<DC.InputRowRight>
						<div style={{ display: "flex", alignItems: "center" }}>
							<div style={{ display: "inline-block", marginRight: 10 }}>@</div>
							<WbInput onChange={e => { updateField({ emailDomain: e.target.value }) }} />
						</div>
					</DC.InputRowRight>
				</DC.InputRow>
			</DC.Body>
			<Spacer height={20} />

			<DC.Body>
				<DC.RadioRow>
					<DC.RadioRowButton>
						<RadioButton
							value={options.step1.USE_EXISTING_COMPANY}
							style={{ padding: 0, paddingRight: 10 }}
							onClick={() => { updateField({ option: options.step1.USE_EXISTING_COMPANY }) }}
						/>
					</DC.RadioRowButton>
					<DC.RadioRowTitle>
						Use Existing Company
					</DC.RadioRowTitle>
				</DC.RadioRow>

				<DC.InputRow>
					<DC.InputRowLeft>
						Choose Company
					</DC.InputRowLeft>
					<DC.InputRowRight>
						<WbInput />
					</DC.InputRowRight>
				</DC.InputRow>

				<DC.InputRow>
					<DC.InputRowLeft>
						Email Domain
					</DC.InputRowLeft>
					<DC.InputRowRight>
						<div style={{ display: "flex", alignItems: "center" }}>
							<div style={{ display: "inline-block", marginRight: 10 }}>@</div>
							<WbInput onChange={e => { updateField({ emailDomain: e.target.value }) }} />
						</div>
					</DC.InputRowRight>
				</DC.InputRow>
			</DC.Body>
		</>
	)
}
```
