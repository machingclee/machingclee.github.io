---
title: "Swagger-UI for Spring Boot in SnapStarted Lambda"
date: 2025-01-02
id: blog0357
tag: springboot, swagger-ui
toc: true
intro: "We study the integration of snapStarted lambda with API-gateway."
---

<style>
  img {
    max-width: 660px;
  }
</style>

#### Setup in Spring Boot Application

##### Installation

```kotlin
// build.gradle.kts

dependencies {
    ...
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0")
}
```

##### Configurations

###### Resource config

```kotlin
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
class SwaggerConfig : WebMvcConfigurer {
    override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
        registry
            .addResourceHandler("/swagger-ui/**")
            .addResourceLocations("classpath:/META-INF/resources/webjars/swagger-ui/")
            .setCachePeriod(3600)
            .resourceChain(false)
    }
}
```

###### Spring doc config

The following is a technical way to solve the resource mapping problem due to the proxy via API-Gayeway when routing traffic to our lambda function:

```kotlin
import org.springdoc.core.properties.SpringDocConfigProperties
import org.springdoc.core.properties.SwaggerUiConfigParameters
import org.springdoc.core.properties.SwaggerUiConfigProperties
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.core.env.Environment
import org.springframework.core.env.get

@Configuration
class SpringDocConfig(
    @Value("\${stage.env}") private val stage: String,
    private val env: Environment
) {

    private fun getPrefix(): String {
        val isLambda = env["IS_LAMBDA"] == "true"
        val prefix = when (isLambda) {
            true -> "/$stage"
            else -> ""
        }
        return prefix
    }

    @Primary
    @Bean
    fun swaggerUiConfig(swaggerUiConfig: SwaggerUiConfigProperties): SwaggerUiConfigParameters {
        val prefix = getPrefix()
        return SwaggerUiConfigParameters(swaggerUiConfig).apply {
            url = "$prefix/v3/api-docs"
            configUrl = "$prefix/v3/api-docs/swagger-config"
            path = "/api"
        }
    }

    @Primary
    @Bean
    fun apiDocsConfig(apiDocsProperties: SpringDocConfigProperties): SpringDocConfigProperties {
        val prefix = getPrefix()
        return apiDocsProperties.apply {
            apiDocs.path = "$prefix/v3/api-docs"
        }
    }
}
```

##### application.yml
###### Issues from API-Gateway
By default response header for the content-type of `js`-bundles generated by `springdoc-openapi-starter` is 
```text
text/javascript
```
from which API-Gateway has no clue how to decode it, and therefore generated something like
```text
Ã:"A",Ã:"A",Ã:"A",Ã:"A",Ã:"A",Ã:"A",Ã :"a",Ã¡:"a",
Ã¢:"a",Ã£:"a",Ã¤:"a",Ã¥:"a",Ã:"C",Ã§:"c",Ã:"D",Ã°:"d",Ã:"E",Ã:"E",Ã
```
in the `js` files. To get around this problem, let's force every response header to have `charset=UTF-8` by setting:

###### Solution via application.yml

```kotlin
// application.yml
server:
  servlet:
    encoding:
      charset: UTF-8
      force: true
```

Now API-Gateway understand how to decode it when they read:

![](/assets/img/2025-01-03-01-39-18.png)


#### Let's Dive Deeper


##### Add auto JWT-header to the controllers

###### Sample result how a token is set up for auto attachment in header

W click `Authorize` and input the token from login API:

[![](/assets/img/2025-01-03-02-18-47.png)](/assets/img/2025-01-03-02-18-47.png)

then simply input the value:

[![](/assets/img/2025-01-03-03-25-52.png)](/assets/img/2025-01-03-03-25-52.png)


###### Configure the annotation for controllers

```kotlin
@Configuration
class SpringDocConfig {
    @Bean
    fun customOpenAPI(): OpenAPI {
        val devServer: Server = Server()
            .url("https://rkfm9k8phd.execute-api.ap-northeast-1.amazonaws.com/dev")
            .description("Development server for alice timetable system")

        return OpenAPI().components(
            Components().addSecuritySchemes("bearer-jwt",
                                            SecurityScheme()
                                                .type(SecurityScheme.Type.HTTP)
                                                .scheme("bearer")
                                                .bearerFormat("JWT")
                                                .`in`(SecurityScheme.In.HEADER)
                                                .name("Authorization")))
            .addSecurityItem(SecurityRequirement().addList("bearer-jwt"))
            .info(Info()
                      .title("Alice Timetable System")
                      .version("1.0"))
            .servers(listOf(devServer))
    }
}
```

Now add the following annotation to our controller:

```kotlin{1}
@SecurityRequirement(name = "bearer-jwt")
@RestController
@RequestMapping("/students")
@AccessToken
class StudentController(
    private val studentApplicationService: StudentApplicationService,
) {
    ...
}
```

###### Let's simplify the annotation

```kotlin
@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@SecurityRequirement(name = "bearer-jwt")
annotation class SwaggerAuthenticated
```

Now 
```kotlin
@SecurityRequirement(name = "bearer-jwt")
```
can be ***replaced*** by 
```kotlin
@SwaggerAuthenticated
```

##### Add multiple servers for API testing

This is suitable for testing the same api in `local`, `dev`, `uat`, `prod`, etc, environments. It provides a dropdown list that we can switch very easily.

[![](/assets/img/2025-01-03-02-32-06.png)](/assets/img/2025-01-03-02-32-06.png)

Let's extend the `customOpenAPI` from the previous section:

```kotlin{22,23}
    @Bean
    fun customOpenAPI(): OpenAPI {
        val devServer = Server()
            .url("https://rkfm9k8phd.execute-api.ap-northeast-1.amazonaws.com/dev")
            .description("Development server for alice timetable system")
        val prodServer = Server()
            .url("")
            .description("Production server for alice timetable system (not created yet)")

        return OpenAPI().components(
            Components().addSecuritySchemes("bearer-jwt",
                                            SecurityScheme()
                                                .type(SecurityScheme.Type.HTTP)
                                                .scheme("bearer")
                                                .bearerFormat("JWT")
                                                .`in`(SecurityScheme.In.HEADER)
                                                .name("Authorization")))
            .addSecurityItem(SecurityRequirement().addList("bearer-jwt"))
            .info(Info()
                      .title("Alice Timetable System")
                      .version("1.0"))
            .servers(listOf(devServer,
                            prodServer))
    }
```

##### Add default example value to `@PathVariable` and `@RequestParam`

```kotlin
    @GetMapping("/{studentId}/student-packages")
    fun getStudentPackages(
        @Parameter(
            description = "Student ID",
            example = "4b05543b-4ee5-4ce7-b045-a8975b305b09",
            required = true
        )
        @PathVariable("studentId") studentId: String
    ): APIResponse<List<StudentPackageResposne>> {
        val packages = AliceLoggingUtil.hibernateSQL {
            studentApplicationService.getStudentPackages(studentId)
        }
        return APIResponse(packages)
    }
```

Which results in 

[![](/assets/img/2025-01-03-02-49-33.png)](/assets/img/2025-01-03-02-49-33.png)

##### Add default example value to `@RequestBody`

```kotlin
    data class LoginRequest(
        @field:Schema(
            description = "User Email",
            example = "test@gmail.com"
        )
        val email: String,
        @field:Schema(
            description = "Password",
            example = "some-password!"
        )
        val password: String,
    )

    @PostMapping("/login")
    fun login(@RequestBody loginRequest: LoginRequest): APIResponse<LoginResult> {
        val (accessToken, refreshToken, accessTokenPayload) = authApplicationService.handleLoginRequest(
            loginRequest
        )
        return APIResponse(LoginResult(accessToken = accessToken,
                                       refreshToken = refreshToken,
                                       user = accessTokenPayload))
    }
```

Which results in 

[![](/assets/img/2025-01-03-02-53-40.png)](/assets/img/2025-01-03-02-53-40.png)

##### Order the Controller by Tags

Sometimes we wish a simple controller (like `auth`) to be always on top of others (as we access it most frequently once our `accessToken` expires).

Here is how we do this:

```kotlin
@Tag(name = "01. Auth Controller")
@RestController
@RequestMapping("/auth")
class AuthContorller(
    private val jwtService: JwtService,
    private val authApplicationService: AuthApplicationService,
    private val authService: AuthService,
) { 
    ...
}
```

Note that by default `swagger-ui` arranges them in `descending` order. To order the controllers correctly let's add:

```yml
# application.yml
springdoc:
  swagger-ui:
    tags-sorter: alpha

```

And we are done!


[![](/assets/img/2025-01-03-03-23-35.png)](/assets/img/2025-01-03-03-23-35.png)
