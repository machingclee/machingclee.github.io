---
title: "Prisma, Prisma-Kysely and Kysely "
date: 2023-11-30
id: blog0221
tag: sql, nodejs, prisma
intro: "Record and introduce the workflow of using prisma and kysely."
toc: true
---

#### Installation

```text
yarn add prisma @prisma/client kysely prisma-kysely
```

#### Prisma

##### schema.prisma: datasource and generator

- Create `./prisma/schema.prisma` at root level.

- In `schema.prisma` write

  ```js
  datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
  }

  generator client {
      provider = "prisma-client-js"
  }

  generator kysely {
      provider = "prisma-kysely"

      // Optionally provide a destination directory for the generated file
      // and a filename of your choice
      output       = "../db"
      fileName     = "types.ts"
      // Optionally generate runtime enums to a separate file
      enumFileName = "enums.ts"
  }
  ```

- We mainly use `prisma` for table migration and `kysely` for actual table communication. `prisma-kysely` also makes use of the models defined in this `schema.prisma` to generate type-safed query builder that we shall see later.

- Note that we **_use both_** generators because the types generated by `kysely` is not readily usable by writing our actual code (which works perfectly fine for its own query-builder).

  On the other hand, types generated by `prisma-client-js` can be brought into writing backend logics.

##### `./db/database.ts`

Note that we have choosen `./db` as the output directory for kysely generated types. Create a `database.ts` and write:

```js
import { DB } from "./types"; // this is the Database interface we defined earlier
import { Pool } from "pg";
import { Kysely, PostgresDialect } from "kysely";

const { DB_DATABASE, DB_HOST, DB_USER, DB_PASSWORD } = process.env;

const dialect = new PostgresDialect({
  pool: new Pool({
    database: DB_DATABASE,
    host: DB_HOST,
    password: DB_PASSWORD,
    user: DB_USER,
    port: 5434,
    max: 10,
  }),
});

export const db =
  new Kysely() <
  DB >
  {
    dialect,
  };
```

If you don't have `types.ts` yet, run `npx prisma generate`, which will trigger kysely generator to produce one for us.

##### schema.prisma: models

###### 1-many

```prisma
model User {
    id        Int     @id @default(autoincrement())
    firstName String  @db.Text
    lastName  String  @db.Text
    companyId Int     @db.Integer
    company   Company @relation(fields: [companyId], references: [id])
}

model Company {
    id   Int    @id @default(autoincrement())
    name String
    User User[]
}
```

- Each user belongs to a company, so we add `companyId` field in `User`.

- Whenever we add a field with model-type (like `Company`, `User[]`) inside a model, we are going to **_create a virtual relation_**. These fields will not be present in our actual table.
- The model with `targetId` should be responsible for creating a foreign key relation, that's why we add
  ```text
  company   Company @relation(fields: [companyId], references: [id])
  ```
  in `User` model.

###### 1-1

The modeling of `1-1` is identical to `1-many` in prisma schema, the only difference is that we drop `[]` in the virtual relation.

```prisma
model File {
    id                 Int         @id @default(autoincrement())
    url                String
    isDeleted          Boolean     @default(false)
    jsonFileFromVoice  Voice?      @relation("jsonFile")
    audioFileFromVoice Voice?      @relation("audioFile")
    image              Image?      @relation("image-file")
    createdAt          DateTime    @default(now())
    updatedAt          DateTime    @updatedAt
}

model Image {
    id           Int         @id @default(autoincrement())
    fileId       Int         @unique
    file         File        @relation("image-file", fields: [fileId], references: [id])
    createdAt    DateTime    @default(now())
    updatedAt    DateTime    @updatedAt
}

model Voice {
    id          Int       @id @default(autoincrement())
    jsonFileId  Int       @unique
    jsonFile    File      @relation("jsonFile", fields: [jsonFileId], references: [id])
    audioFileId Int       @unique
    audioFile   File      @relation("audioFile", fields: [audioFileId], references: [id])
}
```

- Here each `Image` model and `Voice` model refer to a `File` entity which is responsible for handling `File` meta data.

- Note that we use `Voice?`, `Image?` in `File` model. Which are virtual relations meaning `File` has at most one reference from `Voice`, and at most one reference from `Image`.

- Simiarly, recall in `1-many` section we have

  ```prisma
  model Company {
      id   Int    @id @default(autoincrement())
      name String
      User User[]
  }
  ```

  which means that `Company` model has references from many `User`'s (sure, one company has many users).

- When a model has two fields referencing to the same model, we need to add a name `@relation("audioFile")` to distinguish the virtual relationship. In our example, a voice may have `transcription` result saved in a `jsonFile` file, and also the `audioFile` which saves the original sound track.

###### many-many

This time we don't need to write any refereence id:

```prisma
model Project {
    id          Int       @id @default(autoincrement())
    name        String    @db.Text
    joinedUsers User[]    @relation("UserToJoinedProjects")
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
}

model User {
    id                 Int                  @id @default(autoincrement())
    firstName          String               @db.Text
    lastName           String               @db.Text
    passwordHash       String?              @db.Text
    joinedProjects     Project[]            @relation("UserToJoinedProjects")
}
```

Prisma will generate us a table using the relation name (`_UserToJoinedProjects` in our case).

<p></p>

<a href="/assets/tech/221/image.png"><img src="/assets/tech/221/image.png" width="700"></a></Center>

<p></p>
<center></center>

Here `A` is the `userId` and `B` is the `projectId`.

Things become complicated if we want to model a **_project invitation table_**. That table includes

- user who invites
- user who is invited
- project

```model
model ProjectInvitation {
    id         Int     @id @default(autoincrement())
    fromUserId Int
    fromUser   User    @relation("fromUser", fields: [fromUserId], references: [id])
    toUserId   Int
    toUser     User    @relation("toUser", fields: [toUserId], references: [id])
    projectId  Int
    project    Project @relation(fields: [projectId], references: [id])
}

model User {
    id                        Int                  @id @default(autoincrement())
    ...
    projectInvitationSent     ProjectInvitation[]  @relation("fromUser")
    projectInvitationReceived ProjectInvitation[]  @relation("toUser")
    ...
}

model Project {
    id                Int                 @id @default(autoincrement())
    ...
    ProjectInvitation ProjectInvitation[]
    ...
}
```

#### Kysely

##### Left-join as a Json Object

```js
...
.select(eb => [
    jsonObjectFrom(
        eb.selectFrom("User")
            .select([
                "User.companyEmail",
                (eb) => {
                    const firstName = eb.ref("User.firstName");
                    const lastName = eb.ref("User.lastName");
                    return sql<string>`concat(${firstName}, ' ', ${lastName})`.as("name")
                }
            ])
            .whereRef("User.id", "=", "RoomIssue.hostUserId")
    ).as("hostUser")
])
```

##### Left-join as an Array Object

```js
.select(eb => [
    jsonArrayFrom(eb
        .selectFrom("Message")
        .select("id")
        .whereRef("Message.roomIssueId", "=", "RoomIssue.id")
        .whereRef("lastVisit", "<", "Message.createdAt")
        .where("Message.userId", "=", userId)
    ).as("unreadMessages")
])
```

##### Where OR

```js
.where(eb => eb.or([
    eb("RoomIssue.type", "=", "PUBLIC_CHATROOM"),
    eb("RoomIssue.hostUserId", "=", userId)
]))
```

#### Run Custom Migration Script

##### Cast the data type of a Column Which Already has data

Suppose that inside `Project` table we have a **_text_** column `userId` which should have been **_uuid_**. It is tempting to immediately annotate the type `String` by `@db.Uuid`. However, sometimes `prisma` **_doesn't know_** how we intent to modify a table, and it **_tends to erase all the data_** to make sure the migration must succeed (which is harmful of course).

To manually create a migration `sql` script, first we modify the existing `prisma.schema`, we keep migrating via prisma but **_don't let prisma run that auto-generated script_** by

```text
npx prisma migrate dev --create-only
```

Now a new migration folder has been created for us to modify.

Next we encounter the error that warns us the prisma-generated `sql` will fail:

```text
⚠️ We found changes that cannot be executed:

  • Step 0 Changed the type of `userId` on the `Project` table. No cast exists, the column would be dropped and recreated, which cannot be done since the column is required and there is data in the table.
```

Never mind, we are going to change it into working script.

Inside that new migration `sql` file, we write (we need to do experiments to obtain a working script)

```text
alter table "Project" alter COLUMN "userId" set DATA TYPE uuid using "userId"::UUID;
```

The function `"userId"::UUID` can be hinted from first trying to change the type in GUI program (and the function will be mentioned in the error).

Finally we run `npx prisma migrate dev` to execute our custom migration file.

#### Reference

- [Official Documentation](https://kysely.dev/docs/getting-started)
