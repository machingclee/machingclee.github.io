---
title: "Domain Driven Design (DDD) Implementation via Kotlin, Spring Boot and Axon Framework"
date: 2024-07-19
id: blog0279
tag: springboot, kotlin
toc: true
intro: "We record a standard project sturcture using DDD and axon framework."
---

<style>
  img {
    max-width: 660px;
  }
</style>


#### Continuation of Modularized Application, and Why?

> We have studied modularization in [***this article***](/blog/article/Gradle-Fundamentals-Modularization-of-Spring-Boot-Project-and-Dependencies-Control).

- Without `modularization` any package can ***abuse*** imports from each another and there is no way to enjoy good maintainability of DDD.

- Especially when your team has junior/senior developers who cannot grasp the concept of DDD. The project will become a complete mess with their contribution that ***just and only just*** reaches the PM requirements. 

- The culprit:  ***No restriction on what to import within a package***. An illustrative example that is pervasive anywhere:
  
  - Writing queries directly in controller.
  - Executing SQLs to change the state of database directly in controller.

  How could we even write a unit test to such a controller?

- With modularization you have complete control on dependencies (code accessibility) within modules.

#### Concrete References

Let's refer to this diagram of layers in our DDD model:

![](/assets/img/2024-06-22-22-38-50.png)

For concrete example of each layer we can refer to the following repository:

- > [Leave-Application](https://github.com/xlorne/springboot-ddd-examples/tree/master/12-leave-parent)

  This is partially DDD, it illustrates the idea but is not complete (without any commands and event handlers)

For a more complete example using domain events, see:

- > [KOTLIN-DDD-SAMPLE with Axon Framework](https://github.dev/Creditas/kotlin-ddd-sample)

#### Description of Each Module/Layer

##### User Interface Module

This is like our controllers in MVC. The entrypoint of our spring boot application is also here.

##### Application Module

This is like our services in MVC. Service layer in the past will be replaced by domain object's behaviour in this module.

- Note that we create `IRepostories` in `domain` layer, therefore `application` layer has access to repositories (via **interfaces** and spring's **dependencies injection**). 

- In this moduole we also create:
  - `Command`
  - `CommandHandler`
  - `(Domain)EventHandler` (domain-events will be left to `domain` layer)

- Business logic occurs here, for example:
  ```kotlin
  open class OrderCommandHandlers(private val repository: OrderRepository,
                                  private val paymentService: PaymentService,
                                  private val eventBus: EventBus) {
      @CommandHandler
      fun createOrder(command: CreateOrderCommand): UUID {
          val orderId = UUID.randomUUID()
          // with JOOQ we will create many methods in repository via DAO's
          val customer = repository.findCustomerById(command.customerId)
          val order = Order(orderId, customer)
          repository.save(order)

          return orderId
      }
  }
  ```
- We create domain object via repositories, and domain object has behaviour:

  ```kotlin
  @CommandHandler
  fun OrderCommandHandlers.changeProductQuantity(command: ChangeProductQuantityCommand) {
      val order = repository.findById(command.orderId)
      val product = repository.findProductById(command.productId)

      order.changeProductQuantity(product, command.quantity)

      repository.save(order)
  } 
  ```

Since `domain` layer has no access to `infrastructure`, all ***database state changes*** are executed by `application` layer via `Repository.save()`.


##### Domain Module

This module provides domain-specific logic such as 

- Domain objects
  - Note that domain object only describes behaviour, it does not interact with database:
    ```kotlin
    class Order(val id: UUID, val customer: Customer) {
        private val items = mutableListOf<Item>()
        var paid: Boolean = false
            private set

        fun addProduct(product: Product, quantity: Int) {
            if (items.any { it.product == product })
                throw BusinessException("Product already exists!")

            var item = Item(product, quantity)
            items.add(item)
        }

        fun changeProductQuantity(product: Product, quantity: Int) {
            validateIfProductIsOnList(product)

            var item = items.first { it.product == product }
            item.changeQuantity(quantity)
        }

        fun removeProduct(product: Product) {
            validateIfProductIsOnList(product)

            items.removeAll { it.product == product }
        }

        fun pay(creditCard: CreditCard, paymentService: PaymentService, eventBus: EventBus) {
            if (this.paid)
                throw BusinessException("Order already paid!")

            val debitedWithSuccess = paymentService.debitValueByCreditCard(creditCard)
            if (debitedWithSuccess) {
                this.paid = true
                eventBus.publish(GenericEventMessage.asEventMessage<OrderPaid>(OrderPaid(this.id))) //TODO improve this by putting some helpers in a aggregate base class and may creating an DomainEvent base class
            } else {
                throw BusinessException("The amount could not be debited from this credit card")
            }
        }

        fun items() = items.toList()

        private fun validateIfProductIsOnList(product: Product) {
            var isOnList = items.any { it.product == product }
            if (!isOnList)
                throw BusinessException("The product isn't included in this order")
        }
    }
    ```
- Domain events
- Domain services (that contains logic that cannot be part of the aggregate root), and
- The interfaces of repositories for `infrastructure` module.

##### Infrastructure Module

Our domain objects will be created here (while the class definitions come from domain layer). 

- Each domain object will be integrated into an aggregate and equipped with behavious that change the internal state of aggregates.

- Each state of aggregates is saved by `Repository.save(aggregate)` function.



- In this layer we implement both `DAO`'s and `Respository`'s. Most of the time we would see that `Repository` $\to$ `DAO`'s and we call the objects obtained from `DAO` as `POJO`. 

- The `User Interface` (restapi) layer also directly return `POJO`'s to the frontend via `DAO`'s. 

- In case more complex (read) query is needed, we extent `JOOQ`'s auto-generated `DAO` and add extra query method.


- An ordinary repository implmenetation looks as follows (recall that `Order` is an aggregate):

  ```kotlin
  class OrderRepositoryImpl : OrderRepository {
      private val fakeCustomer = Customer(UUID.randomUUID(), "John Doe", Address("a",1, "c", "d"))

      override fun findById(id: UUID): Order {
          return Order(id = id,
                      customer = fakeCustomer)
      }

      override fun findProductById(productId: UUID): Product {
          return Product(productId,
                        "Keyboard",
                        Money.of(19.90, Monetary.getCurrency("USD")))
      }

      override fun findCustomerById(customerId: UUID): Customer {
          return fakeCustomer
      }

      override fun save(order: Order) {
          //TODO
      }
  }
  ```