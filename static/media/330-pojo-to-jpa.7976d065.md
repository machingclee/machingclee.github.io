---
title: "JPA with DB-First Approach: Surgery on JOOQ's POJO into Base @Entity Class"
date: 2024-10-20
id: blog0329
tag: kotlin, springboot, jooq, jpa
toc: true
intro: Working with existing database via jpa amounts to the need to manually model the table by entity classes. We study how to modify the data class generated by JOOQ into a "pre-entity" open class that can be inherited to define domain model.
---

<style>
  img {
    max-width: 660px;
  }
</style>


#### Surgery on JOOQ generated POJO
##### Introduction to the POJO and the Strategy of the Surgery 
We have set `jooq` to generate `pojo` file with `withJpaAnnotation`. 

A typical example of a JOOQ generated `pojo`:

```kt
@Suppress("UNCHECKED_CAST")
@Entity
@Table(
    name = "Order",
    schema = "public",
    indexes = [
        Index(name = "Order_id_userEmail_idx", columnList = "id ASC, userEmail ASC")
    ]
)
data class Order(
    @get:Id
    @get:Column(name = "id")
    var id: UUID? = null,
    @get:Column(name = "error")
    var error: String? = null,
    @get:Column(name = "status")
    var status: Status? = null,
    @get:Column(name = "succeededAt")
    var succeededat: Double? = null,
    @get:Column(name = "failedAt")
    var failedat: Double? = null,
    @get:Column(name = "userEmail", nullable = false)
    var useremail: String,
    @get:Column(name = "orderType")
    var ordertype: Ordertype? = null,
    @get:Column(name = "createdAt")
    var createdat: Double? = null,
    @get:Column(name = "createdAtHK")
    var createdathk: String? = null
): Serializable {
    ...
}
```

What we will be doing:

- Get rid of all kotlin-specific `@get:`'s which cause error by experiment

- Change all `var` to `open var`
- Change `data class` to `open class`
- Rename `Order` to `OrderPreEntity`
- Detect all `enum` type, for each declaration of `enum` we add 
  ```kt
  @Enumerated(EnumType.STRING)
  @JdbcType(PostgreSQLEnumJdbcType::class)
  ```
  this is to enable `jpa` to correctly convert kotlin's `enum` into postgres' `enum` (`jpa` treats `enum` as `small int` by default)
- For every `id: UUID? = null` we add 
  ```kt
  @GeneratedValue(generator = "ulid_as_uuid")
  ```
  since we have custom generation method for `uuid`.
- Remove `@Table(...)` as indexing has been done in db-first step and `@Table` must be bundled with `@Entity`
- Replace `@Entity` by `@MappedSuperclass`
- Remove `Serializable`
- Get rid of everything inside `{ ... }` since no method declaration is needed


##### Sample Result After Surgery

```kt
package com.billie.db.tables.preentities

import com.billie.db.enums.Ordertype
import com.billie.db.enums.Status

import jakarta.persistence.Column
import jakarta.persistence.MappedSuperclass
import jakarta.persistence.GeneratedValue
import jakarta.persistence.Enumerated
import jakarta.persistence.EnumType
import org.hibernate.dialect.PostgreSQLEnumJdbcType
import org.hibernate.annotations.JdbcType
import jakarta.persistence.Id
import java.util.UUID

@MappedSuperclass
open class OrderPreEntity(
    @Id
    @Column(name = "id")
    @GeneratedValue(generator = "ulid_as_uuid")
    open var id: UUID? = null,
    @Column(name = "error")
    open var error: String? = null,
    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    @JdbcType(PostgreSQLEnumJdbcType::class)
    open var status: Status? = null,
    @Column(name = "succeededAt")
    open var succeededat: Double? = null,
    @Column(name = "failedAt")
    open var failedat: Double? = null,
    @Column(name = "userEmail", nullable = false)
    open var useremail: String,
    @Column(name = "orderType")
    @Enumerated(EnumType.STRING)
    @JdbcType(PostgreSQLEnumJdbcType::class)
    open var ordertype: Ordertype? = null,
    @Column(name = "createdAt")
    open var createdat: Double? = null,
    @Column(name = "createdAtHK")
    open var createdathk: String? = null
) 
```


#### Execution of the Surgery via Customized Gradle Task in `build.gradle.kts`

##### The Original Configuration of JOOQ Generation Task
```kts{45-46}
tasks.create("generate") {
    val pojoDir = File("$projectDir/src/main/kotlin/com/billie/db/tables/pojos")
    val preEntityDir = File("$projectDir/src/main/kotlin/com/billie/db/tables/preentities")

    if (pojoDir.exists()) {
        pojoDir.deleteRecursively()
    }
    if (preEntityDir.exists()) {
        preEntityDir.deleteRecursively()
    }

    GenerationTool.generate(
        Configuration()
            .withJdbc(
                Jdbc()
                    .withDriver("org.postgresql.Driver")
                    .withUrl("xxx")
                    .withUser("james.lee")
                    .withPassword("xxx")
            )
            .withGenerator(
                Generator()
                    .withName("org.jooq.codegen.KotlinGenerator")
                    .withDatabase(
                        Database()
                            .withInputSchema("public")
                            .withExcludes("pgp_armor_headers")
                    )
                    .withGenerate(
                        Generate()
                            .withPojos(true)
                            .withDaos(true)
                            .withSpringAnnotations(true)
                            .withJpaAnnotations(true)
                            .withKotlinNotNullPojoAttributes(true)
                            .withKotlinDefaultedNullablePojoAttributes(true)
                    )
                    .withTarget(
                        Target()
                            .withPackageName("$srcPackage.db")
                            .withDirectory("$projectDir/src/main/kotlin")
                    )
            )
    )
    adjustJooqFilesForJPA(pojoDir = pojoDir,
                          preEntityDir = preEntityDir)
}
```

##### The Extra Amendment Step


![](/assets/img/2024-10-23-09-02-15.png)

- Here we copy all `pojos/XXX.kt` into `preentities/XXXPreEntity.kt`. 

- We then do the text manipulation in `adjustJooqFilesForJPA` to turn the jooq's `@Entity` classes into  `@MappedSuperclass` classes which we name as `PreEntity` Classes.
- We later define our own `@Entity` class by extending these `@MappedSuperclass` preentity classes where 
  - We can define our custom `join-column` behaviour (aggregates) and 

  - custom domain behaviours.


```kt
fun getEnumList(): Sequence<String> {
    val enumDir = File("$projectDir/src/main/kotlin/com/billie/db/enums")

    val enumNameList = enumDir.walkTopDown()
        .filter { it.isFile && it.extension == "kt" }
        .map { file -> file.name.replace(".kt", "") }
    return enumNameList
}

fun adjustJooqFilesForJPA(pojoDir: File, preEntityDir: File) {
    if (pojoDir.exists()) {
        val enumNameList = getEnumList()
        preEntityDir.deleteRecursively()
        pojoDir.copyRecursively(preEntityDir)

        preEntityDir.walkTopDown().filter { it.isFile && it.extension == "kt" }.forEach { file ->
            val content = file.readText()

            val modifiedContent = content
                .replace("package com.billie.db.tables.pojos", "package com.billie.db.tables.preentities")
                .replace(Regex("^(data )?class ", RegexOption.MULTILINE),
                         "open class ")
                .replace(Regex("""open class (\w+)\("""),
                         """open class $1PreEntity\(""")
                .replace(Regex("""(@get:.+\n\s*)var""", RegexOption.MULTILINE),
                         "$1open var")
                .replace(Regex("""(@Entity)""", RegexOption.MULTILINE),
                         "@MappedSuperclass")
                .replace("import jakarta.persistence.GeneratedValue",
                         "")
                .replace("import jakarta.persistence.GenerationType",
                         "")
                .replace(Regex("""import jakarta.persistence.Entity""".trimIndent()),
                         """
                     import jakarta.persistence.MappedSuperclass
                     import jakarta.persistence.Enumerated
                     import jakarta.persistence.EnumType
                     import jakarta.persistence.Convert
                     import jakarta.persistence.GeneratedValue
                     import jakarta.persistence.GenerationType
                     import org.hibernate.dialect.PostgreSQLEnumJdbcType
                     import org.hibernate.annotations.JdbcType
                     """.trimIndent().trimMargin())
                .replace(Regex("""@Table.*?open class""", RegexOption.DOT_MATCHES_ALL),
                         "open class")
                .replace(Regex(""": Serializable""", RegexOption.DOT_MATCHES_ALL),
                         "")
                .replace(Regex("""@get:""", RegexOption.MULTILINE),
                         "@")
                .replace(Regex("""@Column\(name = "id"\).*?open var id: UUID\? = null""", RegexOption.DOT_MATCHES_ALL),
                         """
                     |@Column(name = "id")
                     |    @GeneratedValue(generator = "ulid_as_uuid")
                     |    open var id: UUID? = null
                     """.trimMargin()
                )
                .replace("@GeneratedValue(strategy = GenerationType.IDENTITY)", "")
                .replace("open var id: Int? = null",
                         """
                         @GeneratedValue(strategy = GenerationType.IDENTITY)
                         |    open var id: Int? = null
                         """.trimIndent().trimMargin())
                .replace(Regex("""\{.*\}""", RegexOption.DOT_MATCHES_ALL), "")
                .split("\n")
                .map { line ->
                    val isEnumDeclared = enumNameList.any { cls ->
                        val enumFound = line.indexOf(": $cls") > -1
                        enumFound
                    }
                    if (isEnumDeclared) {
                        """
                        |    <<enum_annotations>>
                        $line
                        """.trimIndent().trimMargin()
                    } else {
                        line
                    }
                }.joinToString("\n")
                .replace("<<enum_annotations>>",
                         "@Enumerated(EnumType.STRING)\n    @JdbcType(PostgreSQLEnumJdbcType::class)")

            if (content != modifiedContent) {
                file.writeText(modifiedContent)
                val newFilepath = "${file.parent}/${file.nameWithoutExtension}PreEntity.kt"
                file.renameTo(File(newFilepath))
            }
        }
    } else {
        println("Source POJO folder does not exist")
    }
}
```

#### How to Create Entity Class Using @MappedSuperclass Base Class?

##### IDomainModel Interface

- To reduce boilerplate code we will define default implementation of common methods in an interface which will be implemented by our *rich* domain model.

- We will then create an `Entity` class by implementing and extending `IDomainModel` and `PreEntity`.

```kt
interface IDomainModel {
    @get:Transient
    var domainEvents: MutableList<Any>?

    fun <T> registerEvent(event: T): T {
        Assert.notNull(event, "Domain event must not be null")
        if (domainEvents == null) {
            domainEvents = mutableListOf()
        }
        domainEvents?.add(event as Any)
        return event
    }

    @AfterDomainEventPublication
    fun clearDomainEvents() {
        domainEvents?.clear()
    }

    @DomainEvents
    fun domainEvents(): Collection<Any?> {
        return Collections.unmodifiableList(this.domainEvents ?: mutableListOf())
    }
}
```

##### OrderEntity extending OrderPreEntity with Domain Behaviours

Let's consider the following Order aggregate:

![](/assets/img/2024-10-21-03-15-30.png)

Recall that in our modification strategy we renamed the surgical result of `XXX` `POJO` by `XXXPreEntity`. Now we inherit from these `PreEntity` classes to create our `Entity` classes.

```kt
package com.billie.payment.domain.jpa.model

import com.billie.db.enums.Status
import com.billie.db.tables.pojos.OrderStripe
import com.billie.db.tables.preentities.OrderPreEntity
import com.billie.payment.domain.aggregate.*
import jakarta.persistence.*
import org.hibernate.annotations.DynamicInsert
import org.joda.time.DateTime


@Entity
@DynamicInsert
@Table(name = "Order", schema = "public")
class OrderEntity(override var useremail: String) : IDomainModel, OrderPreEntity(useremail = useremail) {
    @Transient
    override var domainEvents: MutableList<Any>? = null

    @OneToOne(mappedBy = "orderEntity", fetch = FetchType.LAZY, cascade = [CascadeType.PERSIST])
    var orderStripe: OrderStripeEntity? = null

    @OneToOne(mappedBy = "orderEntity", fetch = FetchType.LAZY, cascade = [CascadeType.PERSIST])
    var orderMobile: OrderMobileEntity? = null

    fun updateStripeOrder(stripeOrder: OrderStripe) {
        registerEvent(StripeOrderUpdatedEvent(stripeOrder))
    }

    fun updateOrderDetailSubscriptionId(subscriptionId: String) {
        registerEvent(SubscriptionCreatedEvent(orderId = this.id!!, subscriptionId = subscriptionId))
    }

    fun updateOrderSucceededInfo() {
        this.status = Status.SUCCEEDED
        this.succeededat = DateTime().millis.toDouble()
        registerEvent(
            OrderSucceededEvent(orderId = this.id!!,
                                succeededAt = this.succeededat!!)
        )
    }

    fun createCheckoutSession(
        customerStripeId: String,
        productName: String,
        numOfPersons: Int,
        targetPriceId: String,
    ) {
        val orderId = this.id!!
        registerEvent(CreateStripeSessionCommand(orderId,
                                                 customerStripeId,
                                                 productName,
                                                 numOfPersons,
                                                 targetPriceId))
    }

    fun appleOrderSucceeded() {
        val orderId = this.id!!
        registerEvent(AppleOrderSucceededEvent(orderId))
    }
}
```

##### OrderMobileEntity (Anemic Model)

```kt
@Entity
@DynamicInsert
@Table(name = "Order_Mobile", schema = "public")
class OrderMobileEntity(
    override var orderid: UUID,
    override var period: Period,
    override var platform: Platform,
    override var originalappuserid: String,
    override var useremail: String
) : OrderMobilePreEntity(
    orderid = orderid,
    period = period,
    platform = platform,
    originalappuserid = originalappuserid,
    useremail = useremail,
) {
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "orderId", referencedColumnName = "id", insertable = false, updatable = false)
    var orderEntity: OrderEntity? = null
}
```

##### OrderStripeEntity (Anemic Model)

```kt
@Entity
@DynamicInsert
@Table(name = "Order_Stripe", schema = "public")
class OrderStripeEntity(
    override var actiontype: Actiontype,
    override var numofpersons: Int,
    override var orderid: UUID
) : OrderStripePreEntity(
    actiontype = actiontype,
    numofpersons = numofpersons,
    orderid = orderid
) {
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "orderId", referencedColumnName = "id", insertable = false, updatable = false)
    private val orderEntity: OrderEntity? = null
}
```


##### Finally, Avoid Back Reference that Causes Infinite Loop in Data Serialization

In short
- inside of aggregate root we annotate subaggregate/subdomain object by `@JsonManagedReference`.
- inside of subdomain object we add `@JsonBackReference` to the backward reference.

```kt
import com.fasterxml.jackson.annotation.JsonManagedReference
import com.fasterxml.jackson.annotation.JsonBackReference

class Parent {
    @OneToMany(mappedBy = "parent")
    @JsonManagedReference
    val children: List<Child> = mutableListOf()
}

class Child {
    @ManyToOne // so is @OneToOne
    @JsonBackReference
    lateinit var parent: Parent
}
```


#### JpaRepository
#####  The naming convention of findByXXX

For a complete of convention please visit the 
- [official documentation](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html). 
We just discuss the most common one: `findbyXXX`.

Let's look at our entity class:

```kt{8}
@MappedSuperclass
open class QuotaFreequotarecordPreEntity(
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    open var id: Int? = null,
    @Column(name = "userEmail", nullable = false)
    open var useremail: String,
    @Column(name = "audioUsed", nullable = false)
    open var audioused: Double,
    @Column(name = "summaryUsed", nullable = false)
    open var summaryused: Int
) 
```
Note that our member name is `useremail`, we ***capitalize the first letter*** to get:
```kt
@Repository
interface FreeQuotaJpaRepository : JpaRepository<QuotaFreeEntity, Int> {
    fun findByUseremail(email: String): QuotaFreeEntity?
}
```
the custom repository method depends on the member name of our entity class but ***not on the actual column name***.


##### When Tables and Columns are not Named in Snake Case

Since we use camel case in table and column name instead of lower-letter snake case which `jpa` recognizes by default, in every query we have to ***enclose every single*** occurence of table and column name by two double quote `"`'s. 

We archive this by setting custom naming strategy for `jpa`:

```kt
package com.billie.payment.config.jooq

import org.hibernate.boot.model.naming.Identifier
import org.hibernate.boot.model.naming.PhysicalNamingStrategy
import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment

class QuotedIdentifiersNamingStrategy : PhysicalNamingStrategy {

    override fun toPhysicalCatalogName(name: Identifier?, context: JdbcEnvironment?): Identifier? {
        return name?.let { addQuotes(it) }
    }

    override fun toPhysicalSchemaName(name: Identifier?, context: JdbcEnvironment?): Identifier? {
        return name?.let { addQuotes(it) }
    }

    override fun toPhysicalTableName(name: Identifier?, context: JdbcEnvironment?): Identifier? {
        return name?.let { addQuotes(it) }
    }

    override fun toPhysicalSequenceName(name: Identifier?, context: JdbcEnvironment?): Identifier? {
        return name?.let { addQuotes(it) }
    }

    override fun toPhysicalColumnName(name: Identifier?, context: JdbcEnvironment?): Identifier? {
        return name?.let { addQuotes(it) }
    }

    private fun addQuotes(id: Identifier): Identifier {
        return Identifier.quote(id)
    }
}
```

Next we instruct hibernate to enclose all names by double quote:

```yml
spring:
  jpa:
    hibernate:
      naming:
        physical-strategy: com.billie.payment.config.jooq.QuotedIdentifiersNamingStrategy
    properties:
      hibernate:
        globally_quoted_identifiers: true
        type:
          EnumType: STRING
```





##### Test Cases

###### Set the stage in our test:
```kt-1
@SpringBootTest
class RepositoryTest {

    @Autowired
    private lateinit var orderMobileJpaRepository: OrderMobileJpaRepository

    @Autowired
    private lateinit var orderJpaRepository: OrderJpaRepository

    init {
        System.setProperty("spring.profiles.active", "uat,james_db_and_james_stripe")
    }
```
###### Test if we are abole to persist an entity:
```kt-14
  @Test
  fun `repository save`() {
      val orderEntity = OrderEntity(useremail = "james.lee@wonderbricks.com")
      orderEntity.ordertype = Ordertype.MOBILE
      orderJpaRepository.save(orderEntity)
      val orderMobileEntity = OrderMobileEntity(orderid = orderEntity.id!!,
                                                period = Period.MONTHLY,
                                                platform = Platform.IOS,
                                                originalappuserid = "123",
                                                useremail = orderEntity.useremail)
      orderMobileJpaRepository.save(orderMobileEntity)
}
```

###### Test if the "back-reference" works, and test if the domain event can be caught by `@EventListener`.
```kt-39
    @Test
    fun `repository get`() {
        val orderEntity = orderJpaRepository.findByIdOrNull(UUID.fromString("77d8fd43-b780-4116-9b8e-dc4d032a3754"))
        val orderMobileEntity = orderEntity?.orderMobile
        val theParentEntity = orderMobileEntity?.orderEntity // this is the same as orderEntity in the first line
        theParentEntity?.updateOrderSucceededInfo()
        orderJpaRepository.save(theParentEntity!!) // successfully dispatch an event and we get the event from event handler

        println(orderMobileEntity)
        println(theParentEntity)
    }
}
```

##### Example of Adding Domain Behaviour and How it Actually Works with Our Controller
###### The Entity Class
```kt
data class SeatSummaryCountedEvent(
    val entity: QuotaSeatCounterEntity,
)

@Entity
@DynamicInsert
@Table(name = "Quota_UsageCounter", schema = "public")
class QuotaSeatCounterEntity(
    override var seatid: Int,
    override var audioused: Double,
    override var duedate: Double,
    override var startdate: Double,
) : IDomainModel, QuotaUsagecounterPreEntity(
    seatid = seatid,
    audioused = audioused,
    duedate = duedate,
    startdate = startdate
) {

    @Transient
    override var domainEvents: MutableList<Any>? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "seatId", referencedColumnName = "id", insertable = false, updatable = false)
    @JsonBackReference
    var seat: QuotaSeatEntity? = null

    fun increaseSummaryCount() {
        this.summarygenerated = (this.summarygenerated ?: 0) + 1
        val event = SeatSummaryCountedEvent(this)
        registerEvent(event)
    }
}
```

###### The Controller Method
- The highlighted demonstrates the state change can be managemented by the entity itself. 

- In the past without ORM we have to handle state change in eventListener. With ORM we can now arrange all the in-memory change, and let `jpa` figure out and persist the changes by `repo.save(entity)`.

- By `repo.save()`, `jpa` will look at the member annotated by `@DomainEvents`, then dispatch each event synchronously via `ApplicationEventPublisher`.

```kt{11-12}
    @PostMapping("/increase-summary-count")
    fun increaseSummaryCount(@RequestBody reduceQuotaDto: IncreaseSummaryCountRequest): Response.Success<IncreaseSummaryCountResponse> {
        val user = UserContext.instance.getUser()
        val (counterId) = reduceQuotaDto
        if (counterId == null) {
            val freeQuota = freeQuotaJpaRepository.findByUseremail(user.email) ?: throw Exception("free quota has not created")
            freeQuota.increaseSummaryCount()
            freeQuotaJpaRepository.save(freeQuota)
        }
        val counter = seatCounterJpaRepository.findByIdOrNull(counterId) ?: throw Exception("counter not found")
        counter.increaseSummaryCount()
        seatCounterJpaRepository.save(counter)
        return Response.Success(result = IncreaseSummaryCountResponse(counterId))
    }
```
Therefore when we execute `repo.save()` method, we are actually doing:
- Persist the state change

- Notify all domains which is interested in the `SeatSummaryCountedEvent`.




#### @EntityScan

To play safe just list out all the packages where our entity class live in.

```kt
@EntityScan(basePackages = [
    "com.billie.db",
    "com.billie.payment"
])
class PaymentApplication {
    ...
}
```